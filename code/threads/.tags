!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ASSERT	utility.h	/^#define ASSERT(/;"	d
Acquire	synch.cc	/^void Lock::Acquire() {}$/;"	f	class:Lock
Append	list.cc	/^List::Append(void *item)$/;"	f	class:List
Append	synchlist.cc	/^SynchList::Append(void *item)$/;"	f	class:SynchList
BLOCKED	thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
Broadcast	synch.cc	/^void Condition::Broadcast(Lock* conditionLock) { }$/;"	f	class:Condition
CFILES	Makefile	/^CFILES = $(THREAD_C)$/;"	m
C_OFILES	Makefile	/^C_OFILES = $(THREAD_O)$/;"	m
CheckOverflow	thread.cc	/^Thread::CheckOverflow()$/;"	f	class:Thread
Cleanup	system.cc	/^Cleanup()$/;"	f
Condition	synch.cc	/^Condition::Condition(char* debugName) { }$/;"	f	class:Condition
Condition	synch.h	/^class Condition {$/;"	c
DEBUG	utility.cc	/^DEBUG(char flag, char *format, ...)$/;"	f
DEFINES	Makefile	/^DEFINES = -DTHREADS$/;"	m
DebugInit	utility.cc	/^DebugInit(char *flagList)$/;"	f
DebugIsEnabled	utility.cc	/^DebugIsEnabled(char flag)$/;"	f
ENTRY	switch.c	/^	.EXPORT SWITCH,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
ENTRY	switch.c	/^	.EXPORT ThreadRoot,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
FALSE	bool.h	/^#define FALSE /;"	d
FP	switch.h	/^#define FP /;"	d
FPState	switch.h	/^#define FPState	/;"	d
FPState	switch.h	/^#define FPState /;"	d
FindNextToRun	scheduler.cc	/^Scheduler::FindNextToRun ()$/;"	f	class:Scheduler
Finish	thread.cc	/^Thread::Finish ()$/;"	f	class:Thread
Fork	thread.cc	/^Thread::Fork(VoidFunctionPtr func, int arg)$/;"	f	class:Thread
HFILES	Makefile	/^HFILES = $(THREAD_H)$/;"	m
I0	switch.h	/^#define I0 /;"	d
I1	switch.h	/^#define I1 /;"	d
I2	switch.h	/^#define I2 /;"	d
I3	switch.h	/^#define I3 /;"	d
I4	switch.h	/^#define I4 /;"	d
I5	switch.h	/^#define I5 /;"	d
I6	switch.h	/^#define I6 /;"	d
I7	switch.h	/^#define I7 /;"	d
INCPATH	Makefile	/^INCPATH = -I..\/threads -I..\/machine$/;"	m
InitialArg	switch.c	/^	mov	InitialArg, %l1$/;"	v
InitialArg	switch.h	/^#define InitialArg	/;"	d
InitialArg	switch.h	/^#define InitialArg /;"	d
InitialArgState	switch.h	/^#define InitialArgState	/;"	d
InitialArgState	switch.h	/^#define InitialArgState /;"	d
InitialPC	switch.c	/^	mov	InitialPC, %l0  $/;"	v
InitialPC	switch.h	/^#define InitialPC	/;"	d
InitialPC	switch.h	/^#define InitialPC /;"	d
InitialPCState	switch.h	/^#define InitialPCState	/;"	d
InitialPCState	switch.h	/^#define InitialPCState /;"	d
Initialize	system.cc	/^Initialize(int argc, char **argv)$/;"	f
InterruptEnable	thread.cc	/^static void InterruptEnable() { interrupt->Enable(); }$/;"	f	file:
IsEmpty	list.cc	/^List::IsEmpty() $/;"	f	class:List
JUST_CREATED	thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
LIST_H	list.h	/^#define LIST_H$/;"	d
List	list.cc	/^List::List()$/;"	f	class:List
List	list.h	/^class List {$/;"	c
ListElement	list.cc	/^ListElement::ListElement(void *itemPtr, int sortKey)$/;"	f	class:ListElement
ListElement	list.h	/^class ListElement {$/;"	c
Lock	synch.cc	/^Lock::Lock(char* debugName) {}$/;"	f	class:Lock
Lock	synch.h	/^class Lock {$/;"	c
MAIN	main.cc	/^#define MAIN$/;"	d	file:
MAIN	main.cc	/^#undef MAIN$/;"	d	file:
MachineStateSize	thread.h	/^#define MachineStateSize /;"	d
Mapcar	list.cc	/^List::Mapcar(VoidFunctionPtr func)$/;"	f	class:List
Mapcar	synchlist.cc	/^SynchList::Mapcar(VoidFunctionPtr func)$/;"	f	class:SynchList
P	synch.cc	/^Semaphore::P()$/;"	f	class:Semaphore
PC	switch.h	/^#define   PC /;"	d
PC	switch.h	/^#define PC /;"	d
PCState	switch.h	/^#define PCState	/;"	d
PCState	switch.h	/^#define PCState /;"	d
PRIV_LEV	switch.c	/^	.EXPORT SWITCH,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
PRIV_LEV	switch.c	/^	.EXPORT ThreadRoot,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
Prepend	list.cc	/^List::Prepend(void *item)$/;"	f	class:List
Print	scheduler.cc	/^Scheduler::Print()$/;"	f	class:Scheduler
Print	thread.h	/^    void Print() { printf("%s, ", name); }$/;"	f	class:Thread
READY	thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
RTNVAL	switch.c	/^	.EXPORT SWITCH,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
RTNVAL	switch.c	/^	.EXPORT ThreadRoot,ENTRY,PRIV_LEV=3,RTNVAL=GR$/;"	v
RUNNING	thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	e	enum:ThreadStatus
ReadyToRun	scheduler.cc	/^Scheduler::ReadyToRun (Thread *thread)$/;"	f	class:Scheduler
Release	synch.cc	/^void Lock::Release() {}$/;"	f	class:Lock
Remove	list.cc	/^List::Remove()$/;"	f	class:List
Remove	synchlist.cc	/^SynchList::Remove()$/;"	f	class:SynchList
RestoreUserState	thread.cc	/^Thread::RestoreUserState()$/;"	f	class:Thread
Run	scheduler.cc	/^Scheduler::Run (Thread *nextThread)$/;"	f	class:Scheduler
S0	switch.h	/^#define   S0 /;"	d
S0	switch.h	/^#define S0 /;"	d
S1	switch.h	/^#define   S1 /;"	d
S1	switch.h	/^#define S1 /;"	d
S10	switch.h	/^#define   S10 /;"	d
S11	switch.h	/^#define   S11 /;"	d
S12	switch.h	/^#define   S12 /;"	d
S13	switch.h	/^#define   S13 /;"	d
S14	switch.h	/^#define   S14 /;"	d
S15	switch.h	/^#define   S15 /;"	d
S2	switch.h	/^#define   S2 /;"	d
S2	switch.h	/^#define S2 /;"	d
S3	switch.h	/^#define   S3 /;"	d
S3	switch.h	/^#define S3 /;"	d
S4	switch.h	/^#define   S4 /;"	d
S4	switch.h	/^#define S4 /;"	d
S5	switch.h	/^#define   S5 /;"	d
S5	switch.h	/^#define S5 /;"	d
S6	switch.h	/^#define   S6 /;"	d
S6	switch.h	/^#define S6 /;"	d
S7	switch.h	/^#define   S7 /;"	d
S7	switch.h	/^#define S7 /;"	d
S8	switch.h	/^#define   S8 /;"	d
S9	switch.h	/^#define   S9 /;"	d
SCHEDULER_H	scheduler.h	/^#define SCHEDULER_H$/;"	d
SP	switch.h	/^#define   SP /;"	d
SP	switch.h	/^#define SP /;"	d
STACK_FENCEPOST	thread.cc	/^#define STACK_FENCEPOST /;"	d	file:
SWITCH	switch-old.s	/^SWITCH:$/;"	l
SWITCH	switch.s	/^SWITCH$/;"	l
SWITCH	switch.s	/^SWITCH:$/;"	l
SWITCH	swtch.s	/^SWITCH:$/;"	l
SWITCH_H	switch.h	/^#define SWITCH_H$/;"	d
SYNCHLIST_H	synchlist.h	/^#define SYNCHLIST_H$/;"	d
SYNCH_H	synch.h	/^#define SYNCH_H$/;"	d
SYSTEM_H	system.h	/^#define SYSTEM_H$/;"	d
SaveUserState	thread.cc	/^Thread::SaveUserState()$/;"	f	class:Thread
Scheduler	scheduler.cc	/^Scheduler::Scheduler()$/;"	f	class:Scheduler
Scheduler	scheduler.h	/^class Scheduler {$/;"	c
Semaphore	synch.cc	/^Semaphore::Semaphore(char* debugName, int initialValue)$/;"	f	class:Semaphore
Semaphore	synch.h	/^class Semaphore {$/;"	c
Signal	synch.cc	/^void Condition::Signal(Lock* conditionLock) { }$/;"	f	class:Condition
SimpleThread	threadtest.cc	/^SimpleThread(int which)$/;"	f
Sleep	thread.cc	/^Thread::Sleep ()$/;"	f	class:Thread
SortedInsert	list.cc	/^List::SortedInsert(void *item, int sortKey)$/;"	f	class:List
SortedRemove	list.cc	/^List::SortedRemove(int *keyPtr)$/;"	f	class:List
StackAllocate	thread.cc	/^Thread::StackAllocate (VoidFunctionPtr func, int arg)$/;"	f	class:Thread
StackSize	thread.h	/^#define StackSize	/;"	d
StartupPC	switch.c	/^	call	StartupPC,0$/;"	v
StartupPC	switch.h	/^#define StartupPC	/;"	d
StartupPC	switch.h	/^#define StartupPC /;"	d
StartupPCState	switch.h	/^#define StartupPCState	/;"	d
StartupPCState	switch.h	/^#define StartupPCState /;"	d
SynchList	synchlist.cc	/^SynchList::SynchList()$/;"	f	class:SynchList
SynchList	synchlist.h	/^class SynchList {$/;"	c
THREAD_H	thread.h	/^#define THREAD_H$/;"	d
TRUE	bool.h	/^#define TRUE /;"	d
Thread	thread.cc	/^Thread::Thread(char* threadName)$/;"	f	class:Thread
Thread	thread.h	/^class Thread {$/;"	c
ThreadFinish	thread.cc	/^static void ThreadFinish()    { currentThread->Finish(); }$/;"	f	file:
ThreadPrint	thread.cc	/^void ThreadPrint(int arg){ Thread *t = (Thread *)arg; t->Print(); }$/;"	f
ThreadRoot	switch-old.s	/^ThreadRoot:$/;"	l
ThreadRoot	switch.s	/^ThreadRoot$/;"	l
ThreadRoot	switch.s	/^ThreadRoot:$/;"	l
ThreadRoot	swtch.s	/^ThreadRoot:$/;"	l
ThreadStatus	thread.h	/^enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };$/;"	g
ThreadTest	threadtest.cc	/^ThreadTest()$/;"	f
ThreadTest1	threadtest.cc	/^ThreadTest1()$/;"	f
TimerInterruptHandler	system.cc	/^TimerInterruptHandler(int dummy)$/;"	f	file:
UTILITY_H	utility.h	/^#define UTILITY_H$/;"	d
V	synch.cc	/^Semaphore::V()$/;"	f	class:Semaphore
VoidFunctionPtr	utility.h	/^typedef void (*VoidFunctionPtr)(int arg); $/;"	t
VoidNoArgFunctionPtr	utility.h	/^typedef void (*VoidNoArgFunctionPtr)(); $/;"	t
Wait	synch.cc	/^void Condition::Wait(Lock* conditionLock) { ASSERT(FALSE); }$/;"	f	class:Condition
WhenDonePC	switch.c	/^	mov	WhenDonePC, %l2$/;"	v
WhenDonePC	switch.h	/^#define WhenDonePC	/;"	d
WhenDonePC	switch.h	/^#define WhenDonePC /;"	d
WhenDonePCState	switch.h	/^#define WhenDonePCState	/;"	d
WhenDonePCState	switch.h	/^#define WhenDonePCState /;"	d
Yield	thread.cc	/^Thread::Yield ()$/;"	f	class:Thread
_ANSI_STDARG_H_	stdarg.h	/^#define _ANSI_STDARG_H_$/;"	d
_ASM	switch.c	/^#define _ASM$/;"	d	file:
_ASM	switch.s	/^#define _ASM$/;"	d
_BSD_VA_LIST	stdarg.h	/^#undef _BSD_VA_LIST$/;"	d
_EAX	switch.h	/^#define _EAX /;"	d
_EBP	switch.h	/^#define _EBP /;"	d
_EBX	switch.h	/^#define _EBX /;"	d
_ECX	switch.h	/^#define _ECX /;"	d
_EDI	switch.h	/^#define _EDI /;"	d
_EDX	switch.h	/^#define _EDX /;"	d
_ESI	switch.h	/^#define _ESI /;"	d
_ESP	switch.h	/^#define _ESP /;"	d
_PC	switch.h	/^#define _PC /;"	d
_STDARG_H	stdarg.h	/^#define _STDARG_H$/;"	d
_VA_LIST	stdarg.h	/^#define _VA_LIST /;"	d
_VA_LIST	stdarg.h	/^#define _VA_LIST$/;"	d
_VA_LIST	stdarg.h	/^#undef _VA_LIST$/;"	d
_VA_LIST_	stdarg.h	/^#define _VA_LIST_$/;"	d
_VA_LIST_DEFINED	stdarg.h	/^#define _VA_LIST_DEFINED$/;"	d
_VA_LIST_T_H	stdarg.h	/^#define _VA_LIST_T_H$/;"	d
__GNUC_VA_LIST	stdarg.h	/^#define __GNUC_VA_LIST$/;"	d
__NACHBOOL_H__	bool.h	/^#define __NACHBOOL_H__ /;"	d
__VA_LIST	stdarg.h	/^#define __VA_LIST$/;"	d
__gnuc_va_list	stdarg.h	/^typedef char *__gnuc_va_list;$/;"	t
__gnuc_va_list	stdarg.h	/^typedef void *__gnuc_va_list;$/;"	t
__need___va_list	stdarg.h	/^#undef __need___va_list$/;"	d
__va_copy	stdarg.h	/^#define __va_copy(/;"	d
__va_rounded_size	stdarg.h	/^#define __va_rounded_size(/;"	d
_eax_save	switch.c	/^        movl    _eax_save,%ebx          # get the saved value of eax$/;"	v
a0	switch.c	/^	move	a0, InitialArg$/;"	v
a0	switch.c	/^#define a0 /;"	d	file:
a0	switch.s	/^#define a0      $4      \/* argument registers *\/$/;"	d
a1	switch.c	/^#define a1 /;"	d	file:
a1	switch.s	/^#define a1      $5$/;"	d
copyright	copyright.h	/^static char *copyright = "Copyright (c) 1992-1993 The Regents of the University of California.  All rights reserved.";$/;"	v
counter	switch.c	/^	stw  %rp, PC(%arg0)	;save program counter$/;"	v
currentThread	system.cc	/^Thread *currentThread;			\/\/ the thread we are running now$/;"	v
divRoundDown	utility.h	/^#define divRoundDown(/;"	d
divRoundUp	utility.h	/^#define divRoundUp(/;"	d
done	switch.c	/^	jal 	WhenDonePC	# when were done, call clean up procedure$/;"	v
ebp	switch.c	/^        movl    %ebp,%esp$/;"	v
ebp	switch.c	/^        movl    %ebp,_EBP(%eax)$/;"	v
ebx	switch.c	/^        movl    %ebx,_EAX(%eax)         # store it$/;"	v
ebx	switch.c	/^        movl    %ebx,_EBX(%eax)         # save registers$/;"	v
ecx	switch.c	/^        movl    %ecx,_ECX(%eax)$/;"	v
edi	switch.c	/^        movl    %edi,_EDI(%eax)$/;"	v
edx	switch.c	/^        movl    %edx,_EDX(%eax)$/;"	v
enableFlags	utility.cc	/^static char *enableFlags = NULL; \/\/ controls which DEBUG messages are printed $/;"	v	file:
esi	switch.c	/^        movl    %esi,_ESI(%eax)$/;"	v
esp	switch.c	/^        movl    %esp,_ESP(%eax)         # save stack pointer$/;"	v
fileSystem	system.cc	/^FileSystem  *fileSystem;$/;"	v
first	list.h	/^    ListElement *first;  	\/\/ Head of the list, NULL if list is empty$/;"	m	class:List
fp	switch.c	/^	or	fp,z,z		# Clearing the frame pointer here$/;"	v
fp	switch.c	/^	st	%fp, [%i0]$/;"	v
fp	switch.c	/^#define fp /;"	d	file:
fp	switch.s	/^#define fp      $30     \/* frame pointer *\/$/;"	d
getName	synch.h	/^    char* getName() { return (name); }$/;"	f	class:Condition
getName	synch.h	/^    char* getName() { return name; }	\/\/ debugging assist$/;"	f	class:Lock
getName	synch.h	/^    char* getName() { return name;}			\/\/ debugging assist$/;"	f	class:Semaphore
getName	thread.h	/^    char* getName() { return (name); }$/;"	f	class:Thread
i0	switch.c	/^	st	%i0, [%i0+I0]$/;"	v
i1	switch.c	/^	mov	%i1, %l0$/;"	v
i1	switch.c	/^	st	%i1, [%i0+I1]$/;"	v
i2	switch.c	/^	st	%i2, [%i0+I2]$/;"	v
i3	switch.c	/^	st	%i3, [%i0+I3]$/;"	v
i4	switch.c	/^	st	%i4, [%i0+I4]$/;"	v
i5	switch.c	/^	st	%i5, [%i0+I5]$/;"	v
i7	switch.c	/^	st	%i7, [%i0+I7]$/;"	v
interrupt	system.cc	/^Interrupt *interrupt;			\/\/ interrupt status$/;"	v
item	list.h	/^     void *item; 	    	\/\/ pointer to item on the list$/;"	m	class:ListElement
key	list.h	/^     int key;		    	\/\/ priority, for a sorted list$/;"	m	class:ListElement
l0	switch.c	/^	call	%l0, 1	$/;"	v
l1	switch.c	/^	mov	%l1, %o0   \/* Using delay slot to setup argument to InitialPC *\/$/;"	v
l2	switch.c	/^	call	%l2, 0$/;"	v
last	list.h	/^    ListElement *last;		\/\/ Last element of list$/;"	m	class:List
ld	switch.c	/^	ld	[%l0+I0], %i0$/;"	v
ld	switch.c	/^	ld	[%l0+I1], %i1$/;"	v
ld	switch.c	/^	ld	[%l0+I2], %i2$/;"	v
ld	switch.c	/^	ld	[%l0+I3], %i3$/;"	v
ld	switch.c	/^	ld	[%l0+I4], %i4$/;"	v
ld	switch.c	/^	ld	[%l0+I5], %i5$/;"	v
ld	switch.c	/^	ld	[%l0+I7], %i7$/;"	v
ld	switch.c	/^	ld	[%l0], %i6$/;"	v
list	synchlist.h	/^    List *list;			\/\/ the unsynchronized list$/;"	m	class:SynchList
listEmpty	synchlist.h	/^    Condition *listEmpty;	\/\/ wait in Remove if the list is empty$/;"	m	class:SynchList
lock	synchlist.h	/^    Lock *lock;			\/\/ enforce mutual exclusive access to the list$/;"	m	class:SynchList
machine	system.cc	/^Machine *machine;	\/\/ user program memory and registers$/;"	v
machineState	thread.h	/^    int machineState[MachineStateSize];  \/\/ all registers except for stackTop$/;"	m	class:Thread
main	main.cc	/^main(int argc, char **argv)$/;"	f
max	utility.h	/^#define max(/;"	d
min	utility.h	/^#define min(/;"	d
name	synch.h	/^    char* name;				\/\/ for debugging$/;"	m	class:Lock
name	synch.h	/^    char* name;        \/\/ useful for debugging$/;"	m	class:Semaphore
name	synch.h	/^    char* name;$/;"	m	class:Condition
name	thread.h	/^    char* name;$/;"	m	class:Thread
next	list.h	/^     ListElement *next;		\/\/ next element on list, $/;"	m	class:ListElement
postOffice	system.cc	/^PostOffice *postOffice;$/;"	v
queue	synch.h	/^    List *queue;       \/\/ threads waiting in P() for the value to be > 0$/;"	m	class:Semaphore
r10	switch.c	/^	stw  %r10, S7(%arg0)$/;"	v
r11	switch.c	/^	stw  %r11, S8(%arg0)$/;"	v
r12	switch.c	/^	stw  %r12, S9(%arg0)$/;"	v
r13	switch.c	/^	stw  %r13, S10(%arg0)$/;"	v
r14	switch.c	/^	stw  %r14, S11(%arg0)$/;"	v
r15	switch.c	/^	stw  %r15, S12(%arg0)$/;"	v
r16	switch.c	/^	stw  %r16, S13(%arg0)$/;"	v
r17	switch.c	/^	stw  %r17, S14(%arg0)$/;"	v
r18	switch.c	/^	stw  %r18, S15(%arg0)$/;"	v
r3	switch.c	/^	stw  %r3, S0(%arg0)	;save callee-save registers$/;"	v
r31	switch.c	/^	or   %r31, 0, %rp	;put return address in proper register$/;"	v
r5	switch.c	/^	stw  %r5, S2(%arg0)$/;"	v
r6	switch.c	/^	stw  %r6, S3(%arg0)$/;"	v
r7	switch.c	/^	stw  %r7, S4(%arg0)$/;"	v
r8	switch.c	/^	stw  %r8, S5(%arg0)$/;"	v
r9	switch.c	/^	stw  %r9, S6(%arg0)$/;"	v
ra	switch.c	/^#define ra /;"	d	file:
ra	switch.s	/^#define ra      $31     \/* return address *\/$/;"	d
readyList	scheduler.h	/^    List *readyList;  		\/\/ queue of threads that are ready to run,$/;"	m	class:Scheduler
restore	switch.c	/^	restore$/;"	v
rp	switch.c	/^	or   %r31, 0, %rp	;put return address in proper register$/;"	v
rp	switch.c	/^	stw  %rp, PC(%arg0)	;save program counter$/;"	v
s0	switch.c	/^#define s0 /;"	d	file:
s0	switch.s	/^#define s0      $16     \/* callee saved *\/$/;"	d
s1	switch.c	/^#define s1 /;"	d	file:
s1	switch.s	/^#define s1      $17$/;"	d
s2	switch.c	/^#define s2 /;"	d	file:
s2	switch.s	/^#define s2      $18$/;"	d
s3	switch.c	/^#define s3 /;"	d	file:
s3	switch.s	/^#define s3      $19$/;"	d
s4	switch.c	/^#define s4 /;"	d	file:
s4	switch.s	/^#define s4      $20$/;"	d
s5	switch.c	/^#define s5 /;"	d	file:
s5	switch.s	/^#define s5      $21$/;"	d
s6	switch.c	/^#define s6 /;"	d	file:
s6	switch.s	/^#define s6      $22$/;"	d
s7	switch.c	/^#define s7 /;"	d	file:
s7	switch.s	/^#define s7      $23$/;"	d
scheduler	system.cc	/^Scheduler *scheduler;			\/\/ the ready list$/;"	v
setStatus	thread.h	/^    void setStatus(ThreadStatus st) { status = st; }$/;"	f	class:Thread
sp	switch.c	/^	sw	sp, SP(a0)		# save new stack pointer$/;"	v
sp	switch.c	/^#define sp /;"	d	file:
sp	switch.s	/^#define sp      $29     \/* stack pointer *\/$/;"	d
space	thread.h	/^    AddrSpace *space;			\/\/ User code this thread is running.$/;"	m	class:Thread
stack	thread.h	/^    int* stack; 	 		\/\/ Bottom of the stack $/;"	m	class:Thread
stackTop	thread.h	/^    int* stackTop;			 \/\/ the current stack pointer$/;"	m	class:Thread
stats	system.cc	/^Statistics *stats;			\/\/ performance metrics$/;"	v
status	thread.h	/^    ThreadStatus status;		\/\/ ready, running or blocked$/;"	m	class:Thread
synchDisk	system.cc	/^SynchDisk   *synchDisk;$/;"	v
testnum	threadtest.cc	/^int testnum = 1;$/;"	v
threadToBeDestroyed	system.cc	/^Thread *threadToBeDestroyed;  		\/\/ the thread that just finished$/;"	v
timer	system.cc	/^Timer *timer;				\/\/ the hardware timer device,$/;"	v
userRegisters	thread.h	/^    int userRegisters[NumTotalRegs];	\/\/ user-level CPU register state$/;"	m	class:Thread
va_arg	stdarg.h	/^#define va_arg(/;"	d
va_end	stdarg.h	/^#define va_end(/;"	d
va_end	stdarg.h	/^#undef va_end$/;"	d
va_list	stdarg.h	/^typedef __gnuc_va_list va_list;$/;"	t
va_start	stdarg.h	/^#define va_start(/;"	d
value	synch.h	/^    int value;         \/\/ semaphore value, always >= 0$/;"	m	class:Semaphore
z	switch.c	/^	or	fp,z,z		# Clearing the frame pointer here$/;"	v
z	switch.c	/^#define z /;"	d	file:
z	switch.s	/^#define z       $0      \/* zero register *\/$/;"	d
~Condition	synch.cc	/^Condition::~Condition() { }$/;"	f	class:Condition
~List	list.cc	/^List::~List()$/;"	f	class:List
~Lock	synch.cc	/^Lock::~Lock() {}$/;"	f	class:Lock
~Scheduler	scheduler.cc	/^Scheduler::~Scheduler()$/;"	f	class:Scheduler
~Semaphore	synch.cc	/^Semaphore::~Semaphore()$/;"	f	class:Semaphore
~SynchList	synchlist.cc	/^SynchList::~SynchList()$/;"	f	class:SynchList
~Thread	thread.cc	/^Thread::~Thread()$/;"	f	class:Thread
